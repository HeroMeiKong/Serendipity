# 专有钉钉前端面试指南

原作者：专有钉钉前端团队
原文链接：<https://juejin.cn/post/6986436944913924103>

****
ℹ️：未完成
★：常考
★★：重点掌握
★★★：高频，必背
****

## 面试技巧

建议大家在投递简历时可以先投递一些试水的小公司，先检验一下自己是不是可以胜任这些公司的面试。同时在每一次面试完后记得把面试官提问的问题记录下来，对于没有答上来的问题还是要好好搞懂或者实践一下，因为很有可能下一家的面试官会问同样的问题。在面试的过程中，这里给出几点意见：

- **回答问题不要过于着急，一定要耐心等待面试官把问题说完**
- **回答问题要有逻辑、干练简洁**
- **如果面试官打断你说话，此时一定要谨慎回答，因为很有可能你回答过于繁琐且他对你当下的回答不满意**
- **千万不要长篇大论，千万不要长篇大论，千万不要长篇大论**
- 一个问题不要纠结很久.....
- 心态放平稳，假设第一题你答不上来很正常，面试官不会因为第一题你不会就 PASS 你
- 不会的题目一定不要瞎猜，往往面试官给你挖的坑就是希望你往错的方向猜，一定要答不知道
- 不要说太多跟当前面试题无关的内容，问你什么问题尽量就答什么问题，除非面试官指定你发散一下思维
- 如果没有听懂面试题可以试着询问面试官，您要问的是关于 xxx 的问题么
- 对于某些问题一定要自己先提前精炼一下（例如作用域链、继承以及原型链等问题）
- 如果面试官问的某项技术自己在某些场景使用过或看到别的场景有使用，可结合这些场景进行讲解（让面试官知道你不仅仅理解它，你还会很好的使用它）
- 如果是 Vue 技术栈希望可以深入源码或者至少理解一些别人的源码分析
- 面试一定要真诚，切勿投机取巧
- 面试态度一定要谦虚
- 一定要提前准备好自己想要问的问题，最致命的是面试官问了你一堆问题你却不知道该问面试官什么问题
- 面试之后一定要记录面试官的问题并一一了解，及时了解面试反馈

回答问题的时候要有逻辑并且干练简洁，例如：我觉得可以从 n 个方面进行讲解，首先第 1 个方面是...，其次第 2 个方面是...，我觉得这个问题有几种解决方案，首先第 1 个方案是...，其次第 2 个方案是... 如果你的回答没有逻辑还繁琐且没有命中要点，通常面试官对你的印象会非常差。相反，如果你回答问题过于简洁，通常情况下面试官会觉得你没 Get 到他的问题点（当然会怀疑自己的表述有没有问题），一般都会追加更详细的问题描述。

## 考察内容

专有钉钉的一面面试主要考察以下三个方面的内容：

- 基础知识：考察面试者是否掌握扎实的前端基础知识体系
- 业务思考：考察面试者的业务深度
- 笔试实践：考察面试者基本知识的实践能力，并考察代码风格和逻辑思维能力

需要注意，如果你觉得某些面试题有些突兀，不要觉得惊讶，这些面试题是在不断深入沟通的过程中层层递进被带出来的，其中某些面试题可能相对较偏，纯粹是加分项面试题。

## 基础知识

基础知识主要包含以下几个方面：

- 基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解
- 语法：`JavaScript、ECMAScript、CSS、TypeScript、HTML、Node.js` 等语法的了解和使用
- 框架：`React、Vue、Egg、Koa、Express、Webpack` 等原理的了解和使用
- 工程：编译工具、格式工具、`Git`、`NPM`、单元测试、`Nginx`、`PM2`、`CI / CD` 了解和使用
- 网络：`HTTP、TCP、UDP、WebSocket、Cookie、Session`、跨域、缓存、协议的了解
- 性能：编译性能、监控、白屏检测、`SEO、Service Worker` 等了解
- 插件：`Chrome、Vue CLI 、Webpack` 等插件设计思路的理解
- 系统：`Mac、Windows、Linux` 系统配置的实践
- 后端：`Redis` 缓存、数据库、`Graphql、SSR`、模板引擎等了解和使用

### 基础

1. #### 列举你所了解的计算机存储设备类型？

    现代计算机以存储器为中心，主要由 `CPU、I / O` 设备以及主存储器三大部分组成。各个部分之间通过总线进行连接通信，具体如下图所示：

    ![计算机存储设备结构图](../../images/Interview/InterviewExperience/计算机存储设备结构图.png)

    上图是一种多总线结构的示意图，`CPU`、主存以及 `I / O` 设备之间的所有数据都是通过总线进行并行传输，使用局部总线是为了提高 `CPU` 的吞吐量（`CPU` 不需要直接跟 `I / O` 设备通信），而使用高速总线（更贴近 `CPU`）和 `DMA` 总线则是为了提升高速 `I / O` 设备（外设存储器、局域网以及多媒体等）的执行效率。
    <br>

    主存包括随机存储器 `RAM` 和只读存储器 `ROM`，其中 `ROM` 又可以分为 `MROM`（一次性）、`PROM、EPROM、EEPROM`。`ROM` 中存储的程序（例如启动程序、固化程序）和数据（例如常量数据）在断电后不会丢失。`RAM`  主要分为静态 `RAM（SRAM）`和动态 `RAM（DRAM）`两种类型（`DRAM` 种类很多，包括 `SDRAM、RDRAM、CDRAM` 等），断电后数据会丢失，主要用于存储临时程序或者临时变量数据。`DRAM`  一般访问速度相对较慢。由于现代 `CPU` 读取速度要求相对较高，因此在 `CPU` 内核中都会设计 `L1、L2` 以及 `L3` 级别的多级高速缓存，这些缓存基本是由 `SRAM` 构成，一般访问速度较快。
    <br>

    **其它回答：**
    - 随机存储器 `RAM`
    `SRAM、DRAM`（`SDRAM、RDRAM、CDRAM` 等）

    - 只读存储器 `ROM`
    `MROM、PROM、EPROM、EEPROM`

1. #### 一般代码存储在计算机的哪个设备中？代码在 `CPU` 中是如何运行的？

    高级程序设计语言不能直接被计算机理解并执行，需要通过翻译程序将其转换成特定处理器上可执行的指令，计算机 `CPU` 的简单工作原理如下所示：

    ![计算机 CPU 的简单工作原理](../../images/Interview/InterviewExperience/计算机CPU的简单工作原理.png)

    `CPU` 主要由控制单元、运算单元和存储单元组成（注意忽略了中断系统），各自的作用如下：

    - **控制单元**：在节拍脉冲的作用下，将程序计数器（`Program Counter，PC`）指向的主存或者多级高速缓存中的指令地址送到地址总线，接着获取指令地址所对应的指令并放入指令寄存器 （`Instruction Register，IR`）中，然后通过指令译码器（`Instruction Decoder，ID`）分析指令需要进行的操作，最后通过操作控制器（`Operation Controller，OC`）向其他设备发出微操作控制信号。
    - **运算单元**：如果控制单元发出的控制信号存在算术运算（加、减、乘、除、增 1、减 1、取反等）或者逻辑运算（与、或、非、异或），那么需要通过运算单元获取存储单元的计算数据进行处理。
    - **存储单元**：包括片内缓存和寄存器组，是 `CPU` 中临时数据的存储地方。`CPU` 直接访问主存数据大概需要花费数百个机器周期，而访问寄存器或者片内缓存只需要若干个或者几十个机器周期，因此会使用内部寄存器或缓存来存储和获取临时数据（即将被运算或者运算之后的数据），从而提高 `CPU` 的运行效率。
    <br>

    除此之外，计算机系统执行程序指令时需要花费时间，其中取出一条指令并执行这条指令的时间叫指令周期。指令周期可以分为若干个阶段（取指周期、间址周期、执行周期和中断周期），每个阶段主要完成一项基本操作，完成基本操作的时间叫机器周期。机器周期是时钟周期的分频，例如最经典的 `8051` 单片机的机器周期为 `12` 个时钟周期。时钟周期是 `CPU` 工作的基本时间单位，也可以称为节拍脉冲或 `T` 周期（`CPU` 主频的倒数）。假设 `CPU` 的主频是 `1 GHz`（`1 Hz` 表示每秒运行 `1` 次），那么表示时钟周期为 `1 / 109 s`。理论上 `CPU` 的主频越高，程序指令执行的速度越快。
    <br>

    **其它回答：**
    ① 易失性执行之前，我们的代码主要存储在**内存**中。
    ② `CPU` 读取内存中的数据并放在寄存器内，将寄存器中的数据写入内存并进行有序的四则运算、相关指令，在此过程中，寄存器主要用于存放计算数据，运算器负责操作寄存器中的数据

1. #### 什么是指令和指令集？

    上图右侧主存中的指令是 `CPU` 可以支持的处理命令，一般包含算术指令（加和减）、逻辑指令（与、或和非）、数据指令（移动、输入、删除、加载和存储）、流程控制指令以及程序结束指令等，由于 `CPU` 只能识别二进制码，因此指令是由二进制码组成。除此之外，指令的集合称为指令集（例如汇编语言就是指令集的一种表现形式），常见的指令集有精简指令集（`ARM`）和复杂指令集（`Inter X86`）。一般指令集决定了 `CPU` 处理器的硬件架构，规定了处理器的相应操作。
    <br>

    **其它回答：**
    指令一般是指机器指令，是计算机可完成一个独立计算逻辑所要执行的的命令；一台常规的计算机的所有指令的集合，就是该计算机的指令集。

1. #### ℹ️复杂指令集和精简指令集有什么区别？

1. #### ℹ️`JavaScript` 是如何运行的？解释型语言和编译型语言的差异是什么？

    早期的计算机只有机器语言时，程序设计必须用二进制数（`0` 和 `1`）来编写程序，并且要求程序员对计算机硬件和指令集非常了解，编程的难度较大，操作极易出错。为了解决机器语言的编程问题，慢慢开始出现了符号式的汇编语言（采用 `ADD、SUB、MUL、DIV` 等符号代表加减乘除）。为了使得计算机可以识别汇编语言，需要将汇编语言翻译成机器能够识别的机器语言（处理器的指令集）：

    ![基础-5-1](../../image/../images/Interview/InterviewExperience/基础-5-1.png)

    由于每一种机器的指令系统不同，需要不同的汇编语言程序与之匹配，因此程序员往往需要针对不同的机器了解其硬件结构和指令系统。为了可以抹平不同机器的指令系统，使得程序员可以更加关注程序设计本身，先后出现了各种面向问题的高级程序设计语言，例如 `BASIC` 和 `C`，具体过程如下图所示：

    ![基础-5-2](../../image/../images/Interview/InterviewExperience/基础-5-2.png)

    高级程序语言会先翻译成汇编语言或者其他中间语言，然后再根据不同的机器翻译成机器语言进行执行。除此之外，汇编语言虚拟机和机器语言机器之间还存在一层操作系统虚拟机，主要用于控制和管理操作系统的全部硬件和软件资源（随着超大规模集成电路技术的不断发展，一些操作系统的软件功能逐步由硬件来替换，例如目前的操作系统已经实现了部分程序的固化，简称固件，将程序永久性的存储在 `ROM` 中）。机器语言机器还可以继续分解成微程序机器，将每一条机器指令翻译成一组微指令（微程序）进行执行。
    <br>

    上述虚拟机所提供的语言转换程序被称为编译器，主要作用是将某种语言编写的源程序转换成一个等价的机器语言程序，编译器的作用如下图所示：

    ![基础-5-3](../../image/../images/Interview/InterviewExperience/基础-5-3.png)

    例如 `C` 语言，可以先通过 `gcc` 编译器生成 `Linux` 和 `Windows` 下的目标 `.o` 和 `.obj` 文件（`object` 文件，即目标文件），然后将目标文件与底层系统库文件、应用程序库文件以及启动文件链接成可执行文件在目标机器上执行。
    <br>

    >温馨提示：感兴趣的同学可以了解一下 `ARM` 芯片的程序运行原理，包括使用 `IDE` 进行程序的编译（`IDE` 内置编译器，主流编译器包含 `ARMCC、IAR` 以及 `GCC FOR ARM` 等，其中一些编译器仅仅随着 `IDE` 进行捆绑发布，不提供独立使用的能力，而一些编译器则随着 `IDE` 进行发布的同时，还提供命令行接口的独立使用方式）、通过串口进行程序下载（下载到芯片的代码区初始启动地址映射的存储空间地址）、启动的存储空间地址映射（包括系统存储器、闪存 `FLASH`、内置 `SRAM` 等）、芯片的程序启动模式引脚 `BOOT` 的设置（例如调试代码时常常选择内置 `SRAM`、真正程序运行的时候选择闪存 `FLASH`）等。
    <br>

    如果某种高级语言或者应用语言（例如用于人工智能的计算机设计语言）转换的目标语言不是特定计算机的汇编语言，而是面向另一种高级程序语言（很多研究性的编译器将 `C` 作为目标语言），那么还需要将目标高级程序语言再进行一次额外的编译才能得到最终的目标程序，这种编译器可称为源到源的转换器。
    <br>

    除此之外，有些程序设计语言将编译的过程和最终转换成目标程序进行执行的过程混合在一起，这种语言转换程序通常被称为解释器，主要作用是将某种语言编写的源程序作为输入，将该源程序执行的结果作为输出，解释器的作用如下图所示：

    ![基础-5-4](../../image/../images/Interview/InterviewExperience/基础-5-4.png)

    解释器和编译器有很多相似之处，都需要对源程序进行分析，并转换成目标机器可识别的机器语言进行执行。只是解释器是在转换源程序的同时立马执行对应的机器语言（转换和执行的过程不分离），而编译器得先把源程序全部转换成机器语言并产生目标文件，然后将目标文件写入相应的程序存储器进行执行（转换和执行的过程分离）。例如 `Perl、Scheme、APL` 使用解释器进行转换， `C、C++` 则使用编译器进行转换，而 `Java` 和 `JavaScript` 的转换既包含了编译过程，也包含了解释过程。
    <br>

    **其它回答：**
    ① **`JS` 代码 -> 解析成 `AST`（期间伴随词法分析、语法分析）-> 生成字节码（`V8`）-> 生成机器码（编译器）**
    ② 很多资料会说，`JavaScript、Python、Ruby` 都是"解释型语言"，是通过解释器来实现的。这么说其实很容易引起误解：语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式。
    <br>

    例如说 `C` 一般被认为是“编译型语言”，但 `C` 的解释器也是存在的，例如 `Ch`。同样，`C++` 也有解释器版本的实现，例如 `Cint`。
    <br>

    一般被称为“解释型语言”的是主流实现为解释器的语言，但并不是说它就无法编译。例如说经常被认为是“解释型语言”的 `Scheme` 就有好几种编译器实现，其中率先支持 `R6RS` 规范的大部分内容的是 `Ikarus`，支持在 `x86` 上编译 `Scheme`；它最终不是生成某种虚拟机的字节码，而是直接生成 `x86` 机器码。
    <br>

    解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个 `C` 语言的解释器，里面只是先用普通的 `C` 编译器把源码编译为 `in-memory image`，然后直接调用那个 `image` 去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。
    <br>

    实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为 `AST` 或者字节码，然后由虚拟机去完成实际的执行。所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。
    <br>

    这道题扯多了，肯定有掘金大佬来杠我。我的观点是如果一种语言的主流实现是解释器，其内部是编译器+虚拟机，而虚拟机又是采用解释方式实现的，或者内部实现是编译器+树遍历解释器，那它就是名副其实的“解释型语言”。如果内部用的虚拟机是用编译方式实现的，其实跟普遍印象中的"解释器"还是挺不同的。

1. #### ℹ️简单描述一下 `Babel` 的编译过程？

    待答
    <br>

    **其它回答：**
    首先，`Babel` 的作用是从一种源码到另一种源码，充当转换编译器的作用，可以简述为 **解析（解析 `JS` 代码）->转换（解析和修改 `AST`）->重建（将修改后的 `AST` 转换成另一种 `JS` 代码）**

1. #### ℹ️`JavaScript` 中的数组和函数在内存中是如何存储的？

    `JavaScript` 中的数组存储大致需要分为两种情况：

    - 同种类型数据的数组分配连续的内存空间
    - 存在非同种类型数据的数组使用哈希映射分配内存空间
    <br>

    >温馨提示：可以想象一下连续的内存空间只需要根据索引（指针）直接计算存储位置即可。如果是哈希映射那么首先需要计算索引值，然后如果索引值有冲突的场景下还需要进行二次查找（需要知道哈希的存储方式）。
    <br>

    **其它回答：**
    ① 数组，`JS` 里的数组主要就是**以连续内存形式**存储的 `FixedArray`、**以哈希表形式**存储的 `HashTable`。
    ② 函数，函数属于引用数据类型，存储在**堆**中，在**栈中只存地址**来表示对堆内存中的引用。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

1. #### ★★★ℹ️浏览器和 `Node.js` 中的事件循环机制有什么区别？

    更多：<https://juejin.cn/post/6844903843197616136#heading-3>
    <br>

    事件触发线程管理的任务队列是如何产生的呢？事实上这些任务就是从 `JS` 引擎线程本身产生的，主线程在运行时会产生执行栈，栈中的代码调用某些异步 `API` 时会在任务队列中添加事件，栈中的代码执行完毕后，就会读取任务队列中的事件，去执行事件对应的回调函数，如此循环往复，形成事件循环机制。`JS` 中有两种任务类型：微任务（`microtask`）和宏任务（`macrotask`），在 `ES6` 中，`microtask` 称为 `jobs`，`macrotask` 称为 `task`：

    - 宏任务： `script`（主代码块）、`setTimeout、setInterval、setImmediate、I/O、UI rendering`
    - 微任务：`process.nextTick（Nodejs）、Promise、Object.observe、MutationObserver`
    <br>

    `Node.js` 中 `Event Loop` 和浏览器中 `Event Loop` 有什么区别

    ```javascript
      ┌───────────────────────┐
    ┌─>│        timers         │<————— 执行 setTimeout()、setInterval() 的回调
    │  └──────────┬────────────┘
    |             |<-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调
    │  ┌──────────┴────────────┐
    │  │     pending callbacks │<————— 执行由上一个 Tick 延迟下来的 I/O 回调（待完善，可忽略）
    │  └──────────┬────────────┘
    |             |<-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调
    │  ┌──────────┴────────────┐
    │  │     idle, prepare     │<————— 内部调用（可忽略）
    │  └──────────┬────────────┘     
    |             |<-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调
    |             |                   ┌───────────────┐
    │  ┌──────────┴────────────┐      │   incoming:   │ - (执行几乎所有的回调，除了 close callbacks、timers、setImmediate)
    │  │         poll          │<─────┤  connections, │ 
    │  └──────────┬────────────┘      │   data, etc.  │ 
    │             |                   |               | 
    |             |                   └───────────────┘
    |             |<-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调
    |  ┌──────────┴────────────┐      
    │  │        check          │<————— setImmediate() 的回调将会在这个阶段执行
    │  └──────────┬────────────┘
    |             |<-- 执行所有 Next Tick Queue 以及 MicroTask Queue 的回调
    │  ┌──────────┴────────────┐
    └──┤    close callbacks    │<————— socket.on('close', ...)
      └───────────────────────┘
    ```

    `Node.js` 中宏任务分成了几种类型，并且放在了不同的 `task queue` 里。不同的 `task queue` 在执行顺序上也有区别，微任务放在了每个 `task queue` 的末尾：

    - `setTimeout/setInterval` 属于 `timers` 类型；
    - `setImmediate` 属于 `check` 类型；
    - `socket` 的 `close` 事件属于 `close callbacks` 类型；
    - 其他 `MacroTask` 都属于 `poll` 类型。
    - `process.nextTick` 本质上属于 `MicroTask`，但是它先于所有其他 `MicroTask` 执行；
    - 所有 `MicroTask` 的执行时机在不同类型的 `MacroTask` 切换后。
    - `idle/prepare` 仅供内部调用，我们可以忽略。
    - `pending callbacks` 不太常见，我们也可以忽略。
    <br>

    **其它回答：**更多：<https://www.cnblogs.com/aaron---blog/p/11714638.html>
    ① 浏览器中的事件循环：
    - `macrotasks`(宏任务):
      - `script`(整体代码)
      - `setTimeout`
      - `setInterval`
      - `setImmediate`
      - `I/O`
      - `UI rendering`
      - `event listner`

    - `microtasks`(微任务):
      - `process.nextTick`
      - `Promises`
      - `Object.observe`
      - `MutationObserver`
      <br>

    在浏览器里，每当一个被监听的事件发生时，事件监听器绑定的相关任务就会被添加进回调队列。通过事件产生的任务是异步任务，常见的事件任务包括：

    - 用户交互事件产生的事件任务，比如输入操作；
    - 计时器产生的事件任务，比如 `setTimeout`；
    - 异步请求产生的事件任务，比如 `HTTP` 请求。
    <br>

    主线程运行的时候，会产生堆（`heap`）和栈（`stack`），其中堆为内存、栈为函数调用栈。我们能看到，`Event Loop` 负责执行代码、收集和处理事件以及执行队列中的子任务，具体包括以下过程。

    - `JavaScript` 有一个主线程和调用栈，所有的任务最终都会被放到调用栈等待主线程执行。
    - 同步任务会被放在调用栈中，按照顺序等待主线程依次执行。
    主线程之外存在一个回调队列，回调队列中的异步任务最终会在主线程中以调用栈的方式运行。
    - 同步任务都在主线程上执行，栈中代码在执行的时候会调用浏览器的 `API`，此时会产生一些异步任务。
    - 异步任务会在有了结果（比如被监听的事件发生时）后，将异步任务以及关联的回调函数放入回调队列中。
    - 调用栈中任务执行完毕后，此时主线程处于空闲状态，会从回调队列中获取任务进行处理。
    - 上述过程会不断重复，这就是 `JavaScript` 的运行机制，称为事件循环机制（`Event Loop`）。
    <br>

    ② `NodeJs` 中的事件循环：

    - `timer` 阶段：这个阶段执行 `timer（setTimeout、setInterval）`的回调
    - `I/O callbacks`：执行一些系统调用错误，比如网络通信的错误回调
    - `idle, prepare`：仅 `node` 内部使用
    - `poll`：获取新的 `I/O` 事件, 适当的条件下 `node` 将阻塞在这里
    - `check`：执行 `setImmediate()` 的回调
    - `close callbacks`：执行 `socket` 的 `close` 事件回调
    <br>

    ③ 区别：
    浏览器环境下，`microtask` 的任务队列是每个 `macrotask` 执行完之后执行。而在 `Node.js` 中，`microtask` 会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行 `microtask` 队列的任务。如果是 `node11` 版本一旦执行一个阶段里的一个宏任务(`setTimeout, setInterval` 和 `setImmediate`)就立刻执行微任务队列，这就跟浏览器端运行一致。

    ```javascript
    setTimeout(() => {
      console.log('timer1')
      Promise.resolve().then(function () {
        console.log('promise1')
      })
    }, 0)
    setTimeout(() => {
      console.log('timer2')
      Promise.resolve().then(function () {
        console.log('promise2')
      })
    }, 0)

    // 浏览器环境：
    timer1=>promise1=>timer2=>promise2

    // node V11之后
    timer1=>promise1=>timer2=>promise2

    // node 10及其之前
    timer1=>promise1=>timer2=>promise2 (如果是第二个定时器还未在完成队列中)
    timer1=>timer2=>promise1=>promise2 (如果是第二个定时器已经在完成队列中)
    ```

1. #### ℹ️`ES6 Modules` 相对于 `CommonJS` 的优势是什么？

    待答
    <br>

    **其它回答：**
    区别：
    - `CommonJS` 和 `ES6 Module` 都可以对引入的对象进行赋值，即对对象内部属性的值进行改变；
    - `CommonJS` 模块输出的是一个值的拷贝，`ES6` 模块输出的是值的引用。即 `ES6 Module` 只存只读，不能改变其值，具体点就是指针指向不能变；
    - `CommonJS` 模块是运行时加载，`ES6` 模块是编译时输出接口。
    - `CommonJS` 模块的 `require()` 是同步加载模块，`ES6` 模块的 `import` 命令是异步加载，有一个独立的模块依赖的解析阶段。
    - `import` 的接口是 `read-only`（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对 `commonJS` 对重新赋值（改变指针指向），但是对 `ES6 Module` 赋值会编译报错。
    <br>

    优势：`CommonJS` 加载的是一个对象（即 `module.exports` 属性），该对象只有在脚本运行完才会生成。而 `ES6 Modules` 不是对象，它的对外接口只是一种静态定义，**在代码静态解析阶段就会生成**。

1. #### ℹ️高级程序设计语言是如何编译成机器语言的？

    待答
    <br>

    **其它回答：**
    **高级语言代码->解析成 `AST` (期间伴随词法分析、语法分析)->生成字节码（`V8`）->生成机器码（编译器）**

1. #### ℹ️编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？

    待答
    <br>

    **其它回答：**
    ① 编译器一般由4个阶段工作完成：
      - `Parse` 阶段：`V8` 引擎负责将 `JS` 代码转换成 `AST`（抽象语法树）；
      - `Ignition` 阶段：解释器将 `AST` 转换为字节码，解析执行字节码也会为下一个阶段优化编译提供需要的信息；
      - `TurboFan` 阶段：编译器利用上个阶段收集的信息，将字节码优化为可以执行的机器码；
      - `Orinoco` 阶段：垃圾回收阶段，将程序中不再使用的内存空间进行回收。
      <br>

    ② 数据类型检查一般**在 `Parse` 阶段之前**，因为在生成 `AST` 之前 就要进行语法分析，提取出句子的结构。广义来说输入一般是程序的源码，输出一般是语法树（`syntax tree`，也叫 `parse tree` 等）或抽象语法树（`abstract syntax tree，AST`）。进一步剥开来，广义的解析器里一般会有扫描器（`scanner`，也叫 `tokenizer` 或者 `lexical analyzer`，词法分析器），以及狭义的解析器（`parser`，也叫 `syntax analyzer`，语法分析器）。扫描器的输入一般是文本，经过词法分析，输出是将文本切割为单词的流。狭义的解析器输入是单词的流，经过语法分析，输出是语法树或者精简过的 `AST`。

1. #### ℹ️编译过程中虚拟机的作用是什么？

    待答
    <br>

    **其它回答：**
    虚拟机（`VM`），其意义是实现高级语言的语义。`VM` 既然被称为“机器”，一般认为输入是满足某种指令集架构（`instruction set architecture，ISA`）的指令序列，中间转换为目标 `ISA` 的指令序列并加以执行，输出为程序的执行结果的，就是 `VM`。源与目标 `ISA` 可以是同一种，这是所谓 `same-ISA VM`。
    <br>

    虚拟机并不是神奇的就能执行代码了，它也得采用某种方式去实现输入程序的语义，并且同样有几种选择：
    - “编译”，例如微软的 `.NET` 中的 `CLR`；
    - “解释”，例如 `CPython、CRuby 1.9`，许多老的 `JavaScript` 引擎等；
    - 也有介于两者之间的混合式，例如 `Sun` 的 `JVM`，`HotSpot`。
    <br>

    如果采用编译方式，`VM` 会把输入的指令先转换为某种能被底下的系统直接执行的形式（一般就是 `native code`），然后再执行之；如果采用解释方式，则 `VM` 会把输入的指令逐条直接执行。

1. #### ℹ️什么是中间代码（`IR`），它的作用是什么？

    待答
    <br>

    **其它回答：**
    `IR` 是由 `LLVM` 生成的中间代码，作用是优化编译器或 `VM`，使优化后的机器代码执行效率更高，同时避免缓存编译后的二进制代码占用更多的内存。

1. #### ℹ️什么是交叉编译？

    编译器的设计是一个非常庞大和复杂的软件系统设计，在真正设计的时候需要解决两个相对重要的问题：

    - 如何分析不同高级程序语言设计的源程序
    - 如何将源程序的功能等价映射到不同指令系统的目标机器
    <br>

    为了解决上述两项问题，编译器的设计最终被分解成前端（注意这里所说的不是 `Web` 前端）和后端两个编译阶段，前端用于解决第一个问题，而后端用于解决第二个问题，具体如下图所示：

    ![基础-14-1](../../images/Interview/InterviewExperience/基础-14-1.png)

    上图中的中间表示（`Intermediate Representation，IR`）是程序结构的一种表现方式，它会比 `AST`（后续讲解）更加接近汇编语言或者指令集，同时也会保留源程序中的一些高级信息，除此之外 ，它的种类很多，包括三地址码（`Three Address Code, TAC`）、静态单赋值形式（`Static Single Assignment Form, SSA`）以及基于栈的 `IR` 等，具体作用包括：

    - 靠近前端部分主要适配不同的源程序，靠近后端部分主要适配不同的指令集，更易于编译器的错误调试，容易识别是 `IR` 之前还是之后出问题
    - 如下左图所示，如果没有 `IR`，那么源程序到指令集之间需要进行一一适配，而有了中间表示，则可以使得编译器的职责更加分离，源程序的编译更多关注如何转换成 `IR`，而不是去适配不同的指令集
    - `IR` 本身可以做到多趟迭代从而优化源程序，在每一趟迭代的过程中可以研究代码并记录优化的细节，方便后续的迭代查找并利用这些优化信息，最终可以高效输出更优的目标程序

    ![基础-14-2](../../images/Interview/InterviewExperience/基础-14-2.png)

    由于 `IR` 可以进行多趟迭代进行程序优化，因此在编译器中可插入一个新的优化阶段，如下图所示：

    ![基础-14-3](../../images/Interview/InterviewExperience/基础-14-3.png)

    优化器可以对 `IR` 处理一遍或者多遍，从而生成更快执行速度（例如找到循环中不变的计算并对其进行优化从而减少运算次数）或者更小体积的目标程序，也可能用于产生更少异常或者更低功耗的目标程序。除此之外，前端和后端内部还可以细分为多个处理步骤，具体如下图所示：

    ![基础-14-4](../../images/Interview/InterviewExperience/基础-14-4.png)

    优化器中的每一遍优化处理都可以使用一个或多个优化技术来改进代码，每一趟处理最终都是读写 `IR` 的操作，这样不仅仅可以使得优化可以更加高效，同时也可以降低优化的复杂度，还提高了优化的灵活性，可以使得编译器配置不同的优化选项，达到组合优化的效果。
    <br>

    **其它回答：**
    是指是在一个平台上生成另一个平台上的可执行代码。

1. #### ℹ️发布 / 订阅模式和观察者模式的区别是什么？

    - 观察者模式
    观察者模式是使用一个 `subject` 目标对象维持一系列依赖于它的 `observer` 观察者对象，将有关状态的任何变更自动通知给这一系列观察者对象。当 `subject` 目标对象需要告诉观察者发生了什么事情时，它会向观察者对象们广播一个通知。

    ![基础-15-1](../../images/Interview/InterviewExperience/基础-15-1.png)

    如上图所示：一个或多个观察者对目标对象的状态感兴趣时，可以将自己依附在目标对象上以便注册感兴趣的目标对象的状态变化，目标对象的状态发生改变就会发送一个通知消息，调用每个观察者的更新方法。如果观察者对目标对象的状态不感兴趣，也可以将自己从中分离。
    <br>

    - 发布/订阅模式
    发布/订阅模式使用一个事件通道，这个通道介于订阅者和发布者之间，该设计模式允许代码定义应用程序的特定事件，这些事件可以传递自定义参数，自定义参数包含订阅者需要的信息，采用事件通道可以避免发布者和订阅者之间产生依赖关系。

    ![基础-15-2](../../images/Interview/InterviewExperience/基础-15-2.png)

    - 两者的区别
      - 观察者模式：允许观察者实例对象(订阅者)执行适当的事件处理程序来注册和接收目标实例对象(发布者)发出的通知（即在观察者实例对象上注册update方法），使订阅者和发布者之间产生了依赖关系，且没有事件通道。不存在封装约束的单一对象，目标对象和观察者对象必须合作才能维持约束。 观察者对象向订阅它们的对象发布其感兴趣的事件。通信只能是单向的。
      - 发布/订阅模式：单一目标通常有很多观察者，有时一个目标的观察者是另一个观察者的目标。通信可以实现双向。该模式存在不稳定性，发布者无法感知订阅者的状态。
      <br>

    **其它回答：**
    在观察者模式中，被观察者通常会维护一个观察者列表。当被观察者的状态发生改变时，就会通知观察者。
    <br>

    在发布订阅模式中，具体发布者会动态维护一个订阅者的列表：可在运行时根据程序需要开始或停止发布给对应订阅者的事件通知。
    <br>

    区别在于发布者本身并不维护订阅列表（它不会像观察者一样主动维护一个列表），它会将工作委派给具体发布者（相当于秘书，任何人想知道我的事情，直接问我的秘书就可以了）；订阅者在接收到发布者的消息后，会委派具体的订阅者来进行相关的处理。

1. #### ℹ️装饰器模式一般会在什么场合使用？

    待答
    <br>

    **其它回答：**
    装饰器模式一般是指允许动态地向一个现有的对象添加新的功能，同时又不改变其结构，相当于对现有的对象进行了一个包装。
    <br>

    使用场景很多，比如以前写 `jQuery` 项目，可以自己快速动态拓展 `jQuery` 上面的方法，或者 `vue` 的自定义指令，主要是希望通过继承的方式扩展老旧功能。

1. #### ℹ️谈谈你对大型项目的代码解耦设计理解？什么是 `Ioc`？一般 `DI` 采用什么设计模式实现？

    待答
    <br>

    **其它回答：**
    ① 代码解耦、一定要按模块划分而不是按功能划分
    - 各个模块的生命周期（初始化、销毁）统一由框架进行管理：通过提供通用类 `Disposable`，统一管理相关资源的注册和销毁。
    - 模块间不直接引入和调用，而是通过声明依赖的方式，从框架中获取相应的服务并使用。
    - 不直接使用全局事件进行通信，而是通过订阅具体服务的方式来处理：通过使用同样的方式 `this._register()` 注册事件和订阅事件，将事件相关资源的处理统一挂载到 `dispose()` 方法中
    <br>

    ② 各个部分各个模块开发职责的仔细拆分
    <br>

    ③ 代码开发尽快组件化、提高可复用性，避免业务逻辑过度耦合臃肿，最终难以拓展
    <br>

    `Ioc` 是指依赖注入，简单理解就是借助于"第三方"实现具有依赖关系的对象之间的解耦。一般使用代理模式。

1. #### ℹ️列举你所了解的编程范式？

    编程范式（`Programming paradigm`）是指计算机编程的基本风格或者典型模式，可以简单理解为编程学科中实践出来的具有哲学和理论依据的一些经典原型。常见的编程范式有：

    - 面向过程（`Process Oriented Programming，POP`）
    - 面向对象（`Object Oriented Programming，OOP`）
    - 面向接口（`Interface Oriented Programming，IOP`）
    - 面向切面（`Aspect Oriented Programming，AOP`）
    - 函数式（`Funtional Programming，FP`）
    - 响应式（`Reactive Programming，RP`）
    - 函数响应式（`Functional Reactive Programming，FRP`）
    <br>

    不同的语言可以支持多种不同的编程范式，例如 `C` 语言支持 `POP` 范式，`C++` 和 `Java` 语言支持 `OOP` 范式，`Swift` 语言则可以支持 `FP` 范式，而 `Web` 前端中的 `JavaScript` 可以支持上述列出的所有编程范式。
    <br>

    **其它回答：**
    声明式、命令式、函数式

1. #### ℹ️什么是面向切面（`AOP`）的编程？

    待答
    <br>

    **其它回答：**
    面向切面编程是面向对象中的一种方式而已。在代码执行过程中，动态嵌入其他代码，叫做面向切面编程。

1. #### ℹ️什么是函数式编程？什么是响应式编程？什么是函数响应式编程？

    - 函数式编程：使用函数来进行高效处理数据或数据流的一种编程方式。在数学中，函数的三要素是**定义域、值域和对应关系**。
    <br>

      **假设 `A、B` 是非空数集，对于集合 `A` 中的任意一个数 `x`，在集合 `B` 中都有唯一确定的数 `f(x)` 和它对应，那么可以将 `f` 称为从 `A` 到 `B` 的一个函数，记作：`y = f(x)`。在函数式编程中函数的概念和数学函数的概念类似，主要是描述形参 `x` 和返回值 `y` 之间的对应关系**，如下图所示：

      ![基础-20-1](../../images/Interview/InterviewExperience/基础-20-1.png)

      在实际的编程中，可以将各种明确**对应关系**的函数进行传递、组合从而达到处理数据的最终目的。在此过程中，我们的关注点不在于如何去实现**对应关系，**而在于如何将各种已有的对应关系进行高效联动，从而可快速进行数据转换，达到最终的数据处理目的，提供开发效率。
      <br>

      简单示例
      <br>

      尽管你对函数式编程的概念有所了解，但是你仍然不知道函数式编程到底有什么特点。这里我们仍然拿 `OOP` 编程范式来举例，假设希望通过 `OOP` 编程来解决数学的加减乘除问题：

      ```javascript
      class MathObject {
        constructor(private value: number) {}
        public add(num: number): MathObject {
          this.value += num;
          return this;
        }
        public multiply(num: number): MathObject {
          this.value *= num;
          return this;
        }
        public getValue(): number {
          return this.value;
        }
      }

      const a = new MathObject(1);
      a.add(1).multiply(2).add(a.multiply(2).getValue());
      ```

      我们希望通过上述程序来解决 `(1 + 2) * 2 + 1 * 2` 的问题，但实际上计算出来的结果是 `24`，因为在代码内部有一个 `this.value` 的状态值需要跟踪，这会使得结果不符合预期。 接下来我们采用函数式编程的方式：

      ```javascript
      function add(a: number, b: number): number {
        return a + b;
      }

      function multiply(a: number, b: number): number {
        return a * b;
      }

      const a: number = 1;
      const b: number = 2;

      add(multiply(add(a, b), b), multiply(a, b));
      ```

      以上程序计算的结果是 `8`，完全符合预期。我们知道了 `add` 和 `multiply` 两个函数的实际对应关系，通过将对应关系进行有效的组合和传递，达到了最终的计算结果。除此之外，这两个函数还可以根据数学定律得出更优雅的组合方式：

      ```javascript
      add(multiply(add(a, b), b), multiply(a, b));

      // 根据数学定律分配律：a * b  +  a * c = a * (b + c)，得出：
      // (a + b) * b + a * b = (2a + b) * b

      // 简化上述函数的组合方式
      multiply(add(add(a, a), b), b);
      ```

      我们完全不需要追踪类似于 `OOP` 编程范式中可能存在的内部状态数据，事实上对于数学定律中的结合律、交换律、同一律以及分配律，上述的函数式编程代码足可以胜任。
      <br>

      原则
      <br>

      通过上述简单的例子可以发现，要实现高可复用的函数（对应关系），一定要遵循某些特定的原则，否则在使用的时候可能无法进行高效的传递和组合，例如

      - 高内聚低耦合
      - 最小意外原则
      - 单一职责原则
      ...
      <br>

      如果你之前经常进行无原则性的代码设计，那么在设计过程中可能会出现各种出乎意料的问题（这是为什么新手老是出现一些稀奇古怪问题的主要原因）。函数式编程可以有效的通过一些原则性的约束使你设计出更加健壮和优雅的代码，并且在不断的实践过程中进行经验式叠加，从而提高开发效率。
      <br>

      特点
      <br>

      虽然我们在使用函数的过程中更多的不再关注函数如何实现（对应关系），但是真正在使用和设计函数的时候需要注意以下一些特点：

      - 声明式（`Declarative Programming`）
      - 一等公民（`First Class Function`）
      - 纯函数（`Pure Function`）
      - 无状态和数据不可变（`Statelessness and Immutable Data`）
      ...
      <br>

      - 声明式
      <br>

        我们以前设计的代码通常是命令式编程方式，这种编程方式往往注重具体的实现的过程（对应关系），而函数式编程则采用声明式的编程方式，往往注重如何去组合已有的**对应关系。**简单举个例子：

        ```javascript
        // 命令式
        const array = [0.8, 1.7, 2.5, 3.4];
        const filterArray = [];

        for (let i = 0; i < array.length; i++) {
          const integer = Math.floor(array[i]);
          if (integer < 2) {
            continue;
          }
          filterArray.push(integer);
        }

        // 声明式
        // map 和 filter 不会修改原有数组，而是产生新的数组返回
        [0.8, 1.7, 2.5, 3.4].map((item) => Math.floor(item)).filter((item) => item > 1);
        ```

        命令式代码一步一步的告诉计算机需要执行哪些语句，需要关心变量的实例化情况、循环的具体过程以及跟踪变量状态的变化过程。声明式代码更多的不再关心代码的具体执行过程，而是采用表达式的组合变换去处理问题，不再强调怎么做，而是指明**做什么。**声明式编程方式可以将我们设计代码的关注点彻底从过程式解放出来，从而提高开发效率。
        <br>

      - 一等公民
      <br>

        在 `JavaScript` 中，函数的使用非常灵活，例如可以对函数进行以下操作：

        ```javascript
        interface IHello {
          (name: string): string;
          key?: string;
          arr?: number[];
          fn?(name: string): string;
        }

        // 函数声明提升
        console.log(hello instanceof Object); // true

        // 函数声明提升
        // hello 和其他引用类型的对象一样，都有属性和方法
        hello.key = 'key';
        hello.arr = [1, 2];
        hello.fn = function (name: string) {
          return `hello.fn, ${name}`;
        };

        // 函数声明提升
        // 注意函数表达式不能在声明前执行，例如不能在这里使用 helloCopy('world')
        hello('world'); 

        // 函数
        // 创建新的函数对象，将函数的引用指向变量 hello
        // hello 仅仅是变量的名称
        function hello(name: string): string {
          return `hello, ${name}`;
        }

        console.log(hello.key); // key
        console.log(hello.arr); // [1,2]
        console.log(hello.name); // hello

        // 函数表达式
        const helloCopy: IHello = hello;
        helloCopy('world');

        function transferHello(name: string, hello: Hello) {
          return hello('world');
        }

        // 把函数对象当作实参传递
        transferHello('world', helloCopy);

        // 把匿名函数当作实参传递
        transferHello('world', function (name: string) {
          return `hello, ${name}`;
        });
        ```

        通过以上示例可以看出，函数继承至对象并拥有对象的特性。在 `JavaScript` 中可以对函数进行参数传递、变量赋值或数组操作等等，因此把函数称为一等公民。函数式编程的核心就是对函数进行组合或传递，`JavaScript` 中函数这种灵活的特性是满足函数式编程的重要条件。
        <br>

      - 纯函数
      <br>

        纯函数是是指在相同的参数调用下，函数的返回值唯一不变。这跟数学中函数的映射关系类似，同样的 `x` 不可能映射多个不同的 `y`。使用函数式编程会使得函数的调用非常稳定，从而降低 `Bug` 产生的机率。当然要实现纯函数的这种特性，需要函数不能包含以下一些副作用：

        - 操作 `Http` 请求
        - 可变数据（包括在函数内部改变输入参数）
        - `DOM` 操作
        - 打印日志
        - 访问系统状态
        - 操作文件系统
        - 操作数据库
        ...
        <br>

        从以上常见的一些副作用可以看出，纯函数的实现需要遵循最小意外原则，为了确保函数的稳定唯一的输入和输出，尽量应该避免与函数外部的环境进行任何交互行为，从而防止外部环境对函数内部产生无法预料的影响。纯函数的实现应该自给自足，举几个例子：

        ```javascript
        // 如果使用 const 声明 min 变量（基本数据类型），则可以保证以下函数的纯粹性
        let min: number = 1;

        // 非纯函数
        // 依赖外部环境变量 min，一旦 min 发生变化则输入和返回不唯一
        function isEqual(num: number): boolean {
          return num === min;
        }

        // 纯函数
        function isEqual(num: number): boolean {
          return num === 1;
        }

        // 非纯函数
        function request<T, S>(url: string, params: T): Promise<S> {
          // 会产生请求成功和请求失败两种结果，返回的结果可能不唯一
          return $.getJson(url, params);
        }

        // 纯函数
        function request<T, S>(url: string, params: T) : () => Promise<S> {
          return function() {
            return $.getJson(url, params);
          }
        }
        ```

        纯函数的特性使得函数式编程具备以下特性：

        - 可缓存性（`Cacheable`）
        - 可移植性（`Portable`）
        - 可测试性（`Testable`）
        <br>

        可缓存性和可测试性基于纯函数输入输出唯一不变的特性，可移植性则主要基于纯函数不依赖外部环境的特性。这里举一个可缓存的例子：

        ```javascript
        interface ICache<T> {
          [arg: string]: T;
        }

        interface ISquare<T> {
          (x: T): T;
        }

        // 简单的缓存函数（忽略通用性和健壮性）
        function memoize<T>(fn: ISquare<T>): ISquare<T> {
          const cache: ICache<T> = {};
          return function (x: T) {
            const arg: string = JSON.stringify(x);
            cache[arg] = cache[arg] || fn.call(fn, x);
            return cache[arg];
          };
        }

        // 纯函数
        function square(x: number): number {
          return x * x;
        }

        const memoSquare = memoize<number>(square);
        memoSquare(4);

        // 不会再次调用纯函数 square，而是直接从缓存中获取值
        // 由于输入和输出的唯一性，获取缓存结果可靠稳定
        // 提升代码的运行效率
        memoSquare(4);
        ```

      - 无状态和数据不可变
      <br>

        在函数式编程的简单示例中已经可以清晰的感受到函数式编程绝对不能依赖内部状态，而在纯函数中则说明了函数式编程不能依赖外部的环境或状态，因为一旦依赖的状态变化，不能保证函数根据对应关系所计算的返回值因为状态的变化仍然保持不变。
        <br>

        这里单独讲解一下数据不可变，在 `JavaScript` 中有很多数组操作的方法，举个例子：

        ```javascript
        const arr = [1, 2, 3];

        console.log(arr.slice(0, 2)); // [1, 2]
        console.log(arr); // [1, 2, 3]
        console.log(arr.slice(0, 2)); // [1, 2]
        console.log(arr); // [1, 2, 3]

        console.log(arr.splice(0, 1)); // [1]
        console.log(arr); // [2, 3]
        console.log(arr.splice(0, 1)); // [2]
        console.log(arr); // [3]
        ```

        这里的 `slice` 方法多次调用都不会改变原有数组，且会产生相同的输出。而 `splice` 每次调用都在修改原数组，且产生的输出也不相同。 在函数式编程中，这种会改变原有数据的函数已经不再是纯函数，应该尽量避免使用。
        <br>

        阅读链接：如果想要了解更深入的函数式编程知识点，可以额外阅读[函数式编程指北](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)。
        <br>

    **其它回答：**
    ① 函数式编程是面向数学的抽象，关心数据（代数结构）之间的映射关系。函数式编程将计算描述为一种表达式求值。
    <br>

    ② 响应式编程是一种基于数据流和变化传递的声明式的编程范式。
    <br>

    ③ 函数响应式编程是一种混合体，响应式编程思想为体, 函数式编程思想为用。

1. #### ℹ️响应式编程或者函数响应式编程的使用场景有哪些？

    响应式编程是一种基于**观察者（发布 / 订阅）模式**并且面向**异步（Asynchronous）数据流（Data Stream）和变化传播**的声明式编程范式。响应式编程主要适用的场景包含：

    - 用户和系统发起的连续事件处理，例如鼠标的点击、键盘的按键或者通信设备发起的信号等
    - 非可靠的网络或者通信处理（例如 `HTTP` 网络的请求重试）
    - 连续的异步 IO` 处理
    - 复杂的继发事务处理（例如一次事件涉及到多个继发的网络请求）
    - 高并发的消息处理（例如 `IM` 聊天）
    ...
    <br>

    **其它回答：**

### 语法

1. #### ℹ️如何实现一个上中下三行布局，顶部和底部最小高度是 `100px`，中间自适应?

    待答
    <br>

    **其它回答：**

    ```html
    <div class="layout">
      <div class="top">top</div>
      <div class="content">content</div>
      <div class="bottom">bottom</div>
    </div>
    ```

    ```css
    html,
    body {
      padding: 0;
      margin: 0;
      height: 100%;
      /*定义页面整体高度为100%，重要*/
    }
    .layout {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    .top {
      height: 100px;
      background: red;
    }
    .content {
      flex: 1;
      background: yellow;
    }
    .bottom {
      height: 100px;
      background: blue;
    }
    ```

1. #### ℹ️如何判断一个元素 `CSS` 样式溢出，从而可以选择性的加 `title` 或者 `Tooltip`?

    待答
    <br>

    **其它回答：**
    可以用元素的 `scrollHeight` 属性和 `clientHeight` 属性来判断, 当 `scrollHeight` 大于 `clientHeight` 的时候，元素就是可以垂直滚动的；如果检测水平滚动的话，可以用 `scrollWidth` 和 `clientWidth`。

1. #### 如何让 `CSS` 元素左侧自动溢出（... 溢出在左侧）？

    `CSS` 属性 `direction` 用来设置文本、表列水平溢出的方向。
    - `ltr` 表示从左到右（默认）
    - `rtl` 表示从右到左

    ```html
    <div class="box">
      <div class="text">
        leftleftleftleftleftleftleftleftleftleftleftleftleft
      </div>
    </div>
    ```

    ```css
    .box {
      width: 100px;
      display: flex;
      overflow: hidden;
    }
    .text {
      background: #ccc;
      overflow: hidden;
      text-overflow: ellipsis;
      direction: rtl
    }
    ```

1. #### ℹ️什么是沙箱？浏览器的沙箱有什么作用？

    待答
    <br>

    **其它回答：**
    沙箱设计的目的是为了让不可信的代码运行在一定的环境中，从而限制这些代码访问隔离区之外的资源。

1. #### ℹ️如何处理浏览器中表单项的密码自动填充问题？

    待答
    <br>

    **其它回答：**
    表单中当 `input` 是 `password` 类型时，打开浏览器会自动填充浏览器存储的密码，在 `input` 中加入 `autocomplete="new-password"` 即可解决。之所以 `new-password` 能够解决 `off` 失效的原因是 `autocomplete` 属性的有效值只有 `on` 和 `off`，默认值是 `on`，如果 `autocomplete` 的属性是除 `on` 和 `off` 外的值，那么就是个无效值，那么浏览器就会放弃对该属性的执行。
    <br>

    `<input type="password" name="password" placeholder="请输入密码" autocomplete="new-password"/>`

1. #### ℹ️`Hash` 和 `History` 路由的区别和优缺点？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`JavaScript` 中的 `const` 数组可以进行 `push` 操作吗？为什么？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`JavaScript` 中对象的属性描述符有哪些？分别有什么作用？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`JavaScript` 中 `console` 有哪些 `api`?

    待答
    <br>

    **其它回答：**

1. #### ℹ️简单对比一下 `Callback、Promise、Generator、Async` 几个异步 `API` 的优劣？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Object.defineProperty` 有哪几个参数？各自都有什么作用？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Object.defineProperty` 和 `ES6` 的 `Proxy` 有什么区别？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`ES6` 中 `Symbol、Map、Decorator` 的使用场景有哪些？或者你在哪些库的源码里见过这些 `API` 的使用？

    待答
    <br>

    **其它回答：**

1. #### ℹ️为什么要使用 `TypeScript`? `TypeScript` 相对于 `JavaScript` 的优势是什么？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中 `const` 和 `readonly` 的区别？枚举和常量枚举的区别？接口和类型别名的区别？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中 `any` 类型的作用是什么？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中 `any、never、unknown` 和 `void` 有什么区别？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中 `interface` 可以给 `Function / Array / Class（Indexable）`做声明吗？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中可以使用 `String、Number、Boolean、Symbol、Object` 等给类型做声明吗？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中的 `this` 和 `JavaScript` 中的 `this` 有什么差异？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中使用 `Unions` 时有哪些注意事项？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 如何设计 `Class` 的声明？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中如何联合枚举类型的 `Key`?

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中 `?.、??、!.、_、**` 等符号的含义？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中预定义的有条件类型有哪些？

    待答
    <br>

    **其它回答：**

1. #### ℹ️简单介绍一下 `TypeScript` 模块的加载机制？

    待答
    <br>

    **其它回答：**

1. #### ℹ️简单聊聊你对 `TypeScript` 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中对象展开会有什么副作用吗？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中 `interface、type、enum` 声明有作用域的功能吗？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中同名的 `interface` 或者同名的 `interface` 和 `class` 可以合并吗？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何使 `TypeScript` 项目引入并识别编译为 `JavaScript` 的 `npm` 库包？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 的 `tsconfig.json` 中有哪些配置项信息？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 中如何设置模块导入的路径别名？

    待答
    <br>

    **其它回答：**

### 框架

1. #### ℹ️`React Class` 组件有哪些周期函数？分别有什么作用？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`React Class` 组件中请求可以在 `componentWillMount` 中发起吗？为什么？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`React Class` 组件和 `React Hook` 的区别有哪些？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`React` 中高阶函数和自定义 `Hook` 的优缺点？

    待答
    <br>

    **其它回答：**

1. #### ℹ️简要说明 `React Hook` 中 `useState` 和 `useEffect` 的运行原理？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`React` 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`React Hook` 中 `useEffect` 有哪些参数，如何检测数组依赖项的变化？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`React` 的 `useEffect` 是如何监听数组依赖项的变化的？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`React Hook` 和闭包有什么关联关系？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`React` 中 `useState` 是如何做数据初始化的？

    待答
    <br>

    **其它回答：**

1. #### ℹ️列举你常用的 `React` 性能优化技巧？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Vue 2.x` 模板中的指令是如何解析实现的？

    待答
    <br>

    **其它回答：**

1. #### ℹ️简要说明 `Vue 2.x` 的全链路运作机制？

    待答
    <br>

    **其它回答：**

1. #### ℹ️简单介绍一下 `Element UI` 的框架设计？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何理解 `Vue` 是一个渐进式框架？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Vue` 里实现跨组件通信的方式有哪些？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Vue` 中响应式数据是如何做到对某个对象的深层次属性的监听的？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`MVVM、MVC` 和 `MVP` 的区别是什么？各自有什么应用场景？

    待答
    <br>

    **其它回答：**

1. #### ℹ️什么是 `MVVM` 框架？

    待答
    <br>

    **其它回答：**

### 工程

1. #### ℹ️`Vue CLI 3.x` 有哪些功能？`Vue CLI 3.x` 的插件系统了解？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Vue CLI 3.x` 中的 `Webpack` 是如何组装处理的？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Vue 2.x` 如何支持 `TypeScript` 语法？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何配置环境使得 `JavaScript` 项目可以支持 `TypeScript` 语法？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何对 `TypeScript` 进行 `Lint` 校验？`ESLint` 和 `TSLint` 有什么区别？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Node.js` 如何支持 `TypeScript` 语法？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`TypeScript` 如何自动生成库包的声明文件？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Babel` 对于 `TypeScript` 的支持有哪些限制？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Webpack` 中 `Loader` 和 `Plugin` 的区别是什么？

    待答
    <br>

    **其它回答：**

1. #### ℹ️在 `Webpack` 中是如何做到支持类似于 `JSX` 语法的 `Sourcemap` 定位？

    待答
    <br>

    **其它回答：**

1. #### ℹ️发布 `Npm` 包如何指定引入地址？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何发布开发项目的特定文件夹为 `Npm` 包的根目录？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何发布一个支持 `Tree Shaking` 机制的 `Npm` 包？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Npm` 包中 `peerDependencies` 的作用是什么？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何优雅的调试需要发布的 `Npm` 包？

    待答
    <br>

    **其它回答：**

1. #### ℹ️在设计一些库包时如何生成版本日志？

    待答
    <br>

    **其它回答：**

1. #### ℹ️了解 `Git（Submodule）` 子模块吗？简单介绍一下 `Git` 子模块的作用？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Git` 如何修改已经提交的 `Commit` 信息？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Git` 如何撤销 `Commit` 并保存之前的修改？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Git` 如何 `ignore` 被 `commit` 过的文件？

    待答
    <br>

    **其它回答：**

1. #### ℹ️在使用 `Git` 的时候如何规范 `Git` 的提交说明（`Commit` 信息）？

    待答
    <br>

    **其它回答：**

1. #### ℹ️简述符合 `Angular` 规范的提交说明的结构组成？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Commit` 信息如何和 `Github Issues` 关联？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Git Hook` 在项目中哪些作用？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Git Hook` 中客户端和服务端钩子各自用于什么作用？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Git Hook` 中常用的钩子有哪些？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`pre-commit` 和 `commit-msg` 钩子的区别是什么？各自可用于做什么？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`husky` 以及 `ghook` 等工具制作 `Git Hook` 的原理是什么？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何设计一个通用的 `Git Hook` ？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Git Hook` 可以采用 `Node` 脚本进行设计吗？如何做到？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何确保别人上传的代码没有 `Lint` 错误？如何确保代码构建没有 `Lint` 错误？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何在 `VS Code` 中进行 `Lint` 校验提示？如何在 `VS Code` 中进行 `Lint` 保存格式化？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`ESLint` 和 `Prettier` 的区别是什么？两者在一起工作时会产生问题吗？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何有效的识别 `ESLint` 和 `Prettier` 可能产生冲突的格式规则？如何解决此类规则冲突问题？

    待答
    <br>

    **其它回答：**

1. #### ℹ️在通常的脚手架项目中进行热更新（`hot module replacement`）时如何做到 `ESLint` 实时打印校验错误信息？

    待答
    <br>

    **其它回答：**

1. #### ℹ️谈谈你对 `SourceMap` 的了解？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何调试 `Node.js` 代码？如何调试 `Node.js TypeScript` 代码？在浏览器中如何调试 `Node.js` 代码？

    待答
    <br>

    **其它回答：**

1. #### ℹ️列举你知道的所有构建工具并说说这些工具的优缺点？这些构建工具在不同的场景下应该如何选型？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`VS Code` 配置中的用户和工作区有什么区别？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`VS Code` 的插件可以只对当前项目生效吗？

    待答
    <br>

    **其它回答：**

1. #### ℹ️你所知道的测试有哪些测试类型？

    待答
    <br>

    **其它回答：**

1. #### ℹ️你所知道的测试框架有哪些？

    待答
    <br>

    **其它回答：**

1. #### ℹ️什么是 `e2e` 测试？有哪些 `e2e` 的测试框架？

    待答
    <br>

    **其它回答：**

1. #### ℹ️假设现在有一个插入排序算法，如何对该算法进行单元测试？

    待答
    <br>

    **其它回答：**

### 网络

1. #### ℹ️`CDN` 服务如何实现网络加速？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`WebSocket` 使用的是 `TCP` 还是 `UDP` 协议？

    待答
    <br>

    **其它回答：**

1. #### ℹ️什么是单工、半双工和全双工通信？

    待答
    <br>

    **其它回答：**

1. #### ℹ️简单描述 `HTTP` 协议发送一个带域名的 `URL` 请求的协议传输过程？（`DNS、TCP、IP`、链路）

    待答
    <br>

    **其它回答：**

1. #### ℹ️什么是正向代理？什么是反向代理？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Cookie` 可以在服务端生成吗？`Cookie` 在服务端生成后的工作流程是什么样的？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Session、Cookie` 的区别和关联？如何进行临时性和永久性的 `Session` 存储？

    待答
    <br>

    **其它回答：**

1. #### ℹ️设置 `Cookie` 时候如何防止 `XSS` 攻击？

    待答
    <br>

    **其它回答：**

1. #### ℹ️简单描述一下用户免登陆的实现过程？可能会出现哪些安全性问题？一般如何对用户登录的密码进行加密？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`HTTP` 中提升传输速率的方式有哪些？常用的内容编码方式有哪些？

    待答
    <br>

    **其它回答：**

1. #### ℹ️传输图片的过程中如果突然中断，如何在恢复后从之前的中断中恢复传输？

    待答
    <br>

    **其它回答：**

1. #### ℹ️什么是代理？什么是网关？代理和网关的作用是什么？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`HTTPS` 相比 `HTTP` 为什么更加安全可靠？

    待答
    <br>

    **其它回答：**

1. #### ℹ️什么是对称密钥（共享密钥）加密？什么是非对称密钥（公开密钥）加密？哪个更加安全？

    待答
    <br>

    **其它回答：**

1. #### ℹ️你觉得 `HTTP` 协议目前存在哪些缺点？

    待答
    <br>

    **其它回答：**

### 性能

1. #### ℹ️在 `React` 中如何识别一个表单项里的表单做到了最小粒度 / 代价的渲染？

    待答
    <br>

    **其它回答：**

1. #### ℹ️在 `React` 的开发的过程中你能想到哪些控制渲染成本的方法？

    待答
    <br>

    **其它回答：**

### 插件

1. #### ℹ️`Vue CLI 3.x` 的插件系统是如何设计的？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Webpack` 中的插件机制是如何设计的？

    待答
    <br>

    **其它回答：**

### 系统

1. #### ℹ️`\r\n (CRLF)` 和 `\n (LF)` 的区别是什么？(`VS Code` 的右下角可以切换)

    待答
    <br>

    **其它回答：**

1. #### ℹ️`/dev/null` 的作用是啥？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何在 `Mac` 的终端中设置一个命令的别名？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何在 `Windows` 中设置环境变量？

    待答
    <br>

    **其它回答：**

1. #### ℹ️Ma`c 的文件操作系统默认区分文件路径的大小写吗？

    待答
    <br>

    **其它回答：**

1. #### ℹ️编写 `Shell` 脚本时如何设置文件的绝对路径？

    待答
    <br>

    **其它回答：**

### 后端

1. #### ℹ️`Session、Cookie` 的区别和关联？如何进行临时性和永久性的 `Session` 存储？（同上）

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何部署 `Node.js` 应用？如何处理负载均衡中 `Session` 的一致性问题？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何提升 `Node.js` 代码的运行稳定性？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`GraphQL` 与 `Restful` 的区别，它有什么优点？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Vue SSR` 的工作原理？`Vuex` 的数据如何同构渲染？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`SSR` 技术和 `SPA` 技术的各自的优缺点是什么？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何处理 `Node.js` 渲染 `HTML` 压力过大问题？

    待答
    <br>

    **其它回答：**

## 业务思考

业务思考更多的是结合基础知识的广度和深度进行的具体业务实践，主要包含以下几个方面：

- 工程化：代码部署、`CI / CD` 流程设计、`Jenkins、Gitlab、Docker` 等
- 通用性：脚手架、`SDK`、组件库等框架设计
- 应用框架：`Hybrid` 混合、微前端、`BFF、Monorepo`
- 可视化：
- 低代码：通用表单设计、通用布局设计、通用页面设计、`JSON Schema` 协议设计等
- 测试：`E2E` 测试、单元测试、测试覆盖率、测试报告等
- 业务：数据、体验、复杂度、监控

### 工程化

1. #### ℹ️你所知道的 `CI / CD` 工具有哪些？在项目中有接触过类似的流程吗？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如果让你实现一个 `Web` 前端的 `CI / CD` 工程研发平台，你会如何设计？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如果我们需要将已有项目中的线上产物资源（例如图片）转换成本地私有化资源，你有什么解决方案？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何使用 `Vue CLI 3.x` 定制一个脚手架？比如内部自动集成了 `i18n、 axios、Element UI`、路由守卫等？

    待答
    <br>

    **其它回答：**

1. #### ℹ️`Jenkins` 如何配合 `Node.js` 脚本进行 `CI / CD` 设计？

    待答
    <br>

    **其它回答：**

### 通用性

1. #### ℹ️如果让你设计一个通用的项目脚手架，你会如何设计？一个通用的脚手架一般需要具备哪些能力？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如果让你设计一个通用的工具库，你会如何设计？一个通用的工具库一般需要具备哪些能力？

    待答
    <br>

    **其它回答：**

1. #### ℹ️假设你自己实现的 `React` 或 `Vue` 的组件库要设计演示文档，你会如何设计？设计的文档需要实现哪些功能？

    待答
    <br>

    **其它回答：**

1. #### ℹ️在设计工具库包的时候你是如何设计 `API` 文档的？

    待答
    <br>

    **其它回答：**

### 应用框架

1. #### ℹ️谈谈 `Electron、Nw.js、CEF、Flutter` 和原生开发的理解？

    待答
    <br>

    **其它回答：**

1. #### ℹ️谈谈桌面端应用中 `HotFix` 的理解？

    待答
    <br>

    **其它回答：**

1. #### ℹ️你觉得什么样的场景需要使用微前端框架？

    待答
    <br>

    **其它回答：**

### 可视化

### 低代码

1. #### ℹ️如何设计一个通用的 `JSON Schema` 协议使其可以动态渲染一个通用的联动表单？

    待答
    <br>

    **其它回答：**

1. #### ℹ️一般的低代码平台需要具备哪些能力？

    待答
    <br>

    **其它回答：**

### 测试

### 业务

1. #### ℹ️什么是单点登录？如何做单点登录？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何做一个项目的国际化方案？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何做一个项目的监控和埋点方案？

    待答
    <br>

    **其它回答：**

1. #### ℹ️如何建设项目的稳定性（监控、灰度、错误降级、回滚...）？

    待答
    <br>

    **其它回答：**

1. #### ℹ️一般管理后台型的应用需要考虑哪些性能方面的优化？

    待答
    <br>

    **其它回答：**

1. #### ℹ️简述一些提升项目体验的案例和技术方案（骨架屏、`Loading` 处理、缓存、错误降级、请求重试...）？

    待答
    <br>

    **其它回答：**

1. #### ℹ️假设需要对页面设计一个水印方案，你会如何设计？

    待答
    <br>

    **其它回答：**

## 笔试实践

笔试更多的是考验应聘者的逻辑思维能力和代码书写风格，主要包含以下几个方面：

- 数据结构
- 模板解析
- 设计模式
- 正则表达式
- 框架的部分原理实现
- `TypeScript` 语法
- 算法

### 数据结构

1. #### ℹ️使用 `TypeScript` 语法将没有层级的扁平数据转换成树形结构的数据

  ```javascript
  // 扁平数据
  [{
    name: '文本1',
    parent: null,
    id: 1,
  }, {
    name: '文本2',
    id: 2,
    parent: 1
  }, {
    name: '文本3',
    parent: 2,
    id: 3,
  }]

  // 树状数据
  [{
    name: '文本1',
    id: 1,
    children: [{
      name: '文本2',
      id: 2,
      children: [{
        name: '文本3',
        id: 3
      }]
    }]
  }]
  ```

### 模板解析

1. #### ℹ️实现一个简易的模板引擎

  ```javascript
  const template = '嗨，{{ info.name.value }}您好，今天是星期 {{ day.value }}';

  const data = {
    info: {
      name: {
        value: '张三'
      }
    },
    day: {
      value: '三'
    }
  };

  render(template, data); // 嗨，张三您好，今天是星期三
  ```

### 设计模式

1. #### ℹ️简单实现一个发布 / 订阅模式

### 正则表达式

1. #### ℹ️匹配出字符串中 `const a  = require('xxx')` 中的 `xxx`

### 框架的部分原理实现

### TypeScript 语法

### 算法

****
ℹ️：未完成
★：常考
★★：重点掌握
★★★：高频，必背
****
